package edu.csupomona.cs.cs411.project2.parser;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;

/**
 * This class represents a production used within a context-free grammar. Every
 * Production has a nonterminal left-hand side and a list of both nonterminals
 * and terminals on the right-hand side. Additionally this class has been
 * extended to support the generated of dot markers used in the creation of
 * {@link Parser}s.
 *
 * @author Collin Smith <collinsmith@csupomona.edu>
 */
public class Production implements Iterable<Integer> {
	/**
	 * Delimiter used when printing this Production.
	 */
	private static final String RHS_DELIMIATER = "->";

	/**
	 * Nonterminal generating this Production.
	 */
	private final Integer NONTERMINAL;

	/**
	 * Position of the dot within this Production.
	 */
	private final int POSITION_MARKER;

	/**
	 * Ancestor of this Production (when {@code {@link #POSITION_MARKER} = 0}
	 */
	private final Production ANCESTOR;

	/**
	 * Immutable list of symbols representing the right-hand side of this
	 * Production.
	 */
	private final ImmutableList<Integer> RHS;

	/**
	 * Constructs a Production with a given nonterminal and list of symbols
	 * generated by that nonterminal.
	 *
	 * @param nonterminal nonterminal generating this Production
	 * @param rhs list of nonterminals and terminals generated by this
	 *	Production
	 */
	public Production(Integer nonterminal, ImmutableList<Integer> rhs) {
		this.ANCESTOR = this;
		this.POSITION_MARKER = 0;
		this.RHS = Objects.requireNonNull(rhs);
		this.NONTERMINAL = Objects.requireNonNull(nonterminal);
	}

	/**
	 * Constructs a child of the given Production and steps
	 * {@link #POSITION_MARKER} to its next position.
	 *
	 * @param p Production to base this Production from
	 */
	private Production(Production p) {
		assert p != null;
		this.RHS = p.RHS;
		this.ANCESTOR = p.ANCESTOR;
		this.NONTERMINAL = p.NONTERMINAL;
		this.POSITION_MARKER = p.POSITION_MARKER+1;
	}

	/**
	 * Returns the nonterminal for this Production
	 *
	 * @return symbol identifier for the nonterminal of this Production
	 */
	public Integer getNonterminal() {
		return NONTERMINAL;
	}

	/**
	 * Returns the ancestor Production of this Production
	 *
	 * @return the first Production of any super Productions
	 */
	public Production getAncestor() {
		return ANCESTOR;
	}

	/**
	 * Returns whether or not there is another Production that can be
	 * generated as a child of this Production.
	 *
	 * @return {code true} if there is, otherwise {@code false}
	 */
	public boolean hasNext() {
		return POSITION_MARKER < RHS.size();
	}

	/**
	 * Returns the next child Production of this Production.
	 *
	 * @return child Production of this with the dot moved forward one symbol
	 */
	public Production next() {
		return new Production(this);
	}

	/**
	 * Returns the current symbol of this Production (i.e. the symbol located
	 * as the position behind the dot).
	 *
	 * @return symbol located at the position behind the dot
	 */
	public Integer current() {
		if (POSITION_MARKER == 0) {
			return null;
		}

		return RHS.get(POSITION_MARKER-1);
	}

	/**
	 * Returns the next symbol representing the initial symbol for the next
	 * child Production of this Production.
	 *
	 * @return initial symbol for the next child Production of this Production
	 */
	public Integer peek() {
		if (!hasNext()) {
			return null;
		}

		return RHS.get(POSITION_MARKER);
	}

	/**
	 * Returns the number of symbols on the left-hand side of this Production.
	 *
	 * @return the number of symbols on the left-hand side of this Production
	 */
	public int size() {
		return RHS.size();
	}

	/**
	 * Returns an iterator which iterates through each symbol in the left-hand
	 * side of this Production.
	 *
	 * @return an iterator which iterates through each symbol in the left-hand
	 *	side of this Production.
	 */
	@Override
	public Iterator<Integer> iterator() {
		return RHS.listIterator(POSITION_MARKER);
	}

	/**
	 * A Production is said to be equal to another object iff it is a
	 * Production and all fields are the same (lhs, rhs, and dot position)
	 *
	 * @param obj Object to compare this Production with
	 * @return {@code true} if they are equal, otherwise {@code false}
	 */
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}

		if (!(obj instanceof Production)) {
			return false;
		}

		Production other = (Production)obj;
		if (this.NONTERMINAL != other.NONTERMINAL || this.POSITION_MARKER != other.POSITION_MARKER || this.size() != other.size()) {
			return false;
		}

		return this.RHS.equals(other.RHS);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int hashCode() {
		return Objects.hash(this.NONTERMINAL, this.POSITION_MARKER, this.RHS);
	}

	/**
	 * Returns a readable version of this Production using the passed map to
	 * convert from symbols to their String versions.
	 *
	 * @param translator map to use when translating symbols
	 * @return String representation of this Production
	 */
	public String toString(Map<Integer, String> translator) {
		Preconditions.checkNotNull(translator);

		StringBuilder sb = new StringBuilder(String.format("%16s %s", translator.get(NONTERMINAL), RHS_DELIMIATER));

		int i = 0;
		for (Integer symbol : RHS) {
			if (i == POSITION_MARKER) {
				sb.append(" .");
			}

			sb.append(String.format(" %s", translator.get(symbol)));
			i++;
		}

		if (POSITION_MARKER == RHS.size()) {
			sb.append(" .");
		}

		return sb.toString();
	}

	/**
	 * Returns a String representation of this Production. To return an more
	 * human readable version of this Production, use
	 * {@link #toString(java.util.Map)} instead.
	 *
	 * @return String representation of this Production
	 *
	 * @see #toString(java.util.Map)
	 */
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder(String.format("%d %s", NONTERMINAL, RHS_DELIMIATER));

		int i = 0;
		for (Integer symbol : RHS) {
			if (i == POSITION_MARKER) {
				sb.append(" .");
			}

			sb.append(String.format(" %d", symbol));
			i++;
		}

		if (POSITION_MARKER == RHS.size()) {
			sb.append(" .");
		}

		return sb.toString();
	}
}
